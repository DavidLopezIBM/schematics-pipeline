---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: git-clone-repo
spec:
  params:
    - name: ibmcloud-api
      description: the ibmcloud api
      default: https://cloud.ibm.com
    - name: continuous-delivery-context-secret
      description: name of the secret containing the continuous delivery pipeline context secrets
      default: secure-properties
    - name: API_KEY
      description: field in the secret that contains the api key used to login to ibmcloud
      default: apikey
    - name: git-access-token
      description: |
        (optional) token to access the git repository. If this token is provided, there will not be an attempt
        to use the git token obtained from the authorization flow when adding the git integration in the toolchain
      default: ""
    - name: resource-group
      description: target resource group (name or id) for the ibmcloud login operation
      default: ""
    - name: repository
      description: the git repo url
    - name: branch
      description: the git branch
      default: master
    - name: revision
      description: |
        the git revision/commit to update the git HEAD to.
        Default is to mean only use the branch
      default: ""
    - name: git-client-image
      description: The image to use to run git clone commands
      default: alpine/git
    - name: git-max-retry
      description: max retry for the git clone operation
      default: "1"
    - name: pr-repository
      description: |
        the originating repository where the PullRequest comes from (in case of a fork)
        default to '' means same repository (not a fork) or it can be the same as the repository to clone
      default: ""
    - name: pr-branch
      description: |
        the branch that is the source of this PullRequest
      default: ""
    - name: pr-revision
      description: the commit/revision in the source branch of the PullRequest that is to be built
      default: ""
    - name: directory-name
      description: |
        name of the new directory to clone into.
        Default to . in order to clone at the root of the workspace
        It will be set to the "humanish" part of the repository if this param is set to blank
      default: "."
    - name: properties-file
      description: file containing properties out of clone task (can be a filepath name relative to the workspace)
      default: build.properties
    - name: git-credentials-json-file
      description: |
        JSON file containing the git credentials as found out of the clone task
        (can be a file path relative to the workspace).
        Default to '' meaning no output of this information
      default: ""
    - name: pipeline-debug
      description: Pipeline debug mode
      default: "0"
  results:
    - name: git-repository
      description: The cloned repository
    - name: git-branch
      description: The active branch for the repository
    - name: git-commit
      description: The current commit id that was cloned
    - name: git-user
      description: The auth user that cloned the repository
  workspaces:
    - name: task-ws
      description: The git repo will be cloned onto the volume backing this workspace
      mountPath: /artifacts
  stepTemplate:
    env:
      - name: API_KEY
        valueFrom:
          secretKeyRef:
            name: $(params.continuous-delivery-context-secret)
            key: $(params.API_KEY)
            optional: true
      - name: PIPELINE_DEBUG
        value: $(params.pipeline-debug)
  steps:
    - name: fetch-git-token
      image: ibmcom/pipeline-base-image:2.6
      env:
        - name: REPOSITORY
          value: $(params.repository)
      script: |
        #!/bin/bash
        set -e -o pipefail

        if [ $PIPELINE_DEBUG == 1 ]; then
            pwd
            env
            trap env EXIT
            set -x
        fi

        TOOLCHAIN_ID=$(jq -r '.toolchain_guid' /cd-config/toolchain.json)
        TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json | awk -F: '{print $3}')
        ##########################################################################
        # Setting HOME explicitly to have ibmcloud plugins available
        # doing the export rather than env definition is a workaround
        # until https://github.com/tektoncd/pipeline/issues/1836 is fixed
        export HOME="/root"
        ##########################################################################
        if [[ "$REPOSITORY" != *.git ]]; then
          echo "Adding .git suffix to Repository URL"
          REPOSITORY="${REPOSITORY}.git"
        fi
        GIT_SERVICE_INSTANCE_ID=$(jq -r --arg git_repo "$REPOSITORY" \
          '.services[] | select (.parameters.repo_url==$git_repo) | .instance_id' /cd-config/toolchain.json)
        if [ -z "$GIT_SERVICE_INSTANCE_ID" ]; then
          echo "No Git integration (repository url: $REPOSITORY) found in the toolchain"
          exit 1
        fi
        GIT_SERVICE_TYPE=$(jq -r --arg git_repo "$REPOSITORY" \
          '.services[] | select (.parameters.repo_url==$git_repo) | .service_id' /cd-config/toolchain.json)

        if [ "$GIT_SERVICE_TYPE" == "github" ]; then
          GIT_AUTH_USER="x-oauth-basic"
        elif [ "$GIT_SERVICE_TYPE" == "githubpublic" ]; then
          GIT_AUTH_USER="x-oauth-basic"
        elif [ "$GIT_SERVICE_TYPE" == "hostedgit" ]; then
          GIT_AUTH_USER="oauth2"
        elif [ "$GIT_SERVICE_TYPE" == "gitlab" ]; then
          GIT_AUTH_USER="oauth2"
        elif [ "$GIT_SERVICE_TYPE" == "bitbucketgit" ]; then
          GIT_AUTH_USER="x-token-auth"
        else
          GIT_AUTH_USER="x-token-auth"
        fi;

        GIT_TOKEN="$(params.git-access-token)"
        if [ -z "$GIT_TOKEN" ]; then
          echo "Fetching token for $REPOSITORY"
          ibmcloud config --check-version false
          ibmcloud login --apikey "f9C3JLP0v2lcZeFVcQycnVF0wgLRKjF37GR9lLlfTlRP" -a "https://cloud.ibm.com" -r "us-south"
          if [ "$(params.resource-group)" ]; then
            ibmcloud target -g "$(params.resource-group)"
          fi
          TOKEN=$(ibmcloud iam oauth-tokens --output JSON | jq -r '.iam_token')
          GIT_TOKEN_URL=$(jq -r --arg git_repo "$REPOSITORY" \
            '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.token_url' \
            /cd-config/toolchain.json)

          # GIT_TOKEN_URL is something like
          # https://otc-github-consolidated-broker.us-south.devops.cloud.ibm.com/github/token?git_id=github
          # as there is already an url param git_id, just put the additional ones using &

          GIT_BROKER_URL="${GIT_TOKEN_URL}&toolchain_id=${TOOLCHAIN_ID}&service_instance_id=${GIT_SERVICE_INSTANCE_ID}&repo_url=${REPOSITORY}"
          echo "Doing cURL to ${GIT_BROKER_URL}"

          curl -s -o /steps/github_token_result.json -X GET -H "Accept: application/json" \
            -H "Authorization: $TOKEN" "$GIT_BROKER_URL"
          if jq -e '.access_token' /steps/github_token_result.json > /dev/null 2>&1; then
            GIT_TOKEN=$(jq -r '.access_token' /steps/github_token_result.json)
            echo "Access token found for the Git integration (repository url: $REPOSITORY)"
          else
            echo "No access token found for the Git integration (repository url: $REPOSITORY)"
            cat /steps/github_token_result.json
            exit 1
          fi
        else
          echo "Using git Access Token provided"
        fi

        echo "GIT_REPOSITORY=$REPOSITORY" > /steps/next-step-env.properties
        echo "GIT_AUTH_USER=$GIT_AUTH_USER" >> /steps/next-step-env.properties
        echo "GIT_TOKEN=$GIT_TOKEN" >> /steps/next-step-env.properties
      volumeMounts:
        - mountPath: /cd-config
          name: cd-config-volume
        - mountPath: /steps
          name: steps-volume
    - name: clone-repo
      image: $(params.git-client-image)
      env:
        - name: REPOSITORY
          value: $(params.repository)
        - name: BRANCH
          value: $(params.branch)
        - name: REVISION
          value: $(params.revision)
        - name: PR_REPOSITORY
          value: $(params.pr-repository)
        - name: PR_BRANCH
          value: $(params.pr-branch)
        - name: PR_REVISION
          value: $(params.pr-revision)
        - name: DIRECTORY_NAME
          value: $(params.directory-name)
        - name: PROPERTIES_FILE
          value: $(params.properties-file)
        - name: JSON_FILE_GIT_CREDENTIALS
          value: $(params.git-credentials-json-file)
      script: |
        #!/bin/sh
        set -e

        if [ $PIPELINE_DEBUG == 1 ]; then
            pwd
            env
            trap env EXIT
            set -x
        fi

        ############################
        # Workaround until a null/empty param can be flowing to Task
        # REVISION if not set is define with a single blank value
        BRANCH=$(echo $BRANCH)
        REVISION=$(echo $REVISION)
        PR_REPOSITORY=$(echo $PR_REPOSITORY)
        PR_BRANCH=$(echo $PR_BRANCH)
        PR_REVISION=$(echo $PR_REVISION)
        ############################
        source /steps/next-step-env.properties

        # If $BRANCH is a full git ref then only keep the name part
        BRANCH=$(echo ${BRANCH#"refs/heads/"})

        echo "Cloning $REPOSITORY"
        # Add the proper creds to the git repository
        GIT_URL=$(echo "$REPOSITORY" | sed -e "s/:\/\//:\/\/$GIT_AUTH_USER:$GIT_TOKEN@/g")
        ARTIFACTS_PATH="$(workspaces.output.path)"
        cd $ARTIFACTS_PATH
        if [ "$REVISION" ]; then
          # check if the branch exists (that may not be the case in case of a pipeline-run re-run)
          echo "Fetching specific -${REVISION}- commit"
          if [ -z "$BRANCH" ]; then
            # No branch provided
            _clone_command='git clone -q -n $GIT_URL $DIRECTORY_NAME'
          elif git ls-remote --heads --exit-code $GIT_URL $BRANCH > /dev/null 2>&1; then
            _clone_command='git clone -q -b "$BRANCH" $GIT_URL $DIRECTORY_NAME'
          else
            echo "branch $BRANCH does not exists in $REPOSITORY"
            _clone_command='git clone -q -n $GIT_URL $DIRECTORY_NAME'
          fi
        else
          if [ -z "$BRANCH" ]; then
            # No branch provided
            echo "No branch or revision provided."
            _clone_command='git clone -q -n $GIT_URL $DIRECTORY_NAME'
          else
            _clone_command='git clone -q -b "$BRANCH" $GIT_URL $DIRECTORY_NAME'
          fi
        fi
        _max_retry=$(params.git-max-retry)
        set +e
        eval "$_clone_command"
        _clone_code=$?
        _retry_counter=1
        while [ $_retry_counter -le $_max_retry ]; do
            if [ $_clone_code != 0 ]; then
              echo "Clone was not successful. Code $_clone_code - Retrying shortly..."
              sleep 10
              if [ $_retry_counter -eq $_max_retry ]; then
                  set -e # reset on the last attempt so we fail if all attemps fail
              fi
              eval "$_clone_command"
              let "_retry_counter++"
            else
              break
            fi
        done
        echo "Repository $REPOSITORY successfully cloned"
        set -e

        current_dir=$(pwd)
        if [ -z "$DIRECTORY_NAME" ]; then
          # Find the "humanish" part of the git source repository that corresponds to the clone directory
          # GIT_REPOSITORY contains the repository url with .git suffix
          DIRECTORY_NAME=$(basename "${GIT_REPOSITORY##*/}" .git)
        fi
        cd $DIRECTORY_NAME
        if [ "$REVISION" ]; then
          # Point the HEAD to the specific revision
          git checkout -q $REVISION
        fi
        GIT_COMMIT=$(git show-ref --head | head -n1 | awk '{print $1}')

        # If a Pull Request/Merge Request branch is specified, then
        # execute the git commands to have the cloned git repository directory content
        # to be the result of the merge for pull request/merge request
        if [ "${PR_BRANCH}" ]; then
          echo "Performing Pull Request Checkout & Merge"
          git config --global user.email "cdtektonpipeline@ibm.com"
          git config --global user.name "CD Tekton Pipeline"
          # Clear GIT_COMMIT as the outcome if this task is a non yet known commit
          GIT_COMMIT=""
          if [ -z "$PR_REPOSITORY" ] || [ "$PR_REPOSITORY" == "$REPOSITORY" ]; then
            # Assuming the PR is not coming from a fork as $PR_REPOSITORY is empty or equals to $REPOSITORY
            # Make the manual steps that a merge request action is doing
            git fetch -q origin "${PR_BRANCH}"
            if [ "${PR_REVISION}" ]; then
              if git merge "${PR_REVISION}"; then
                echo "git merge ${PR_REVISION} done"
              else
                exit 1
              fi
            else
              if git merge "origin/${PR_BRANCH}"; then
                echo "git merge origin/${PR_BRANCH} done"
              else
                exit 1
              fi
            fi
            echo -n "git merge of $GIT_REPOSITORY (pr-branch ${PR_BRANCH} - pr_commit ${PR_REVISION}) to "
            echo "(branch $BRANCH - commit $REVISION) done in directory $DIRECTORY_NAME"
          else
            # Assuming the PR is from a fork
            # Expect that the same creds will be sufficient for the git pull from the forked repository
            GIT_PR_REPO_URL=$(echo "$PR_REPOSITORY" | sed -e "s/:\/\//:\/\/$GIT_AUTH_USER:$GIT_TOKEN@/g")
            # Make the manual steps that a merge request action is doing
            # Step 1
            if git pull "${GIT_PR_REPO_URL}" "${PR_BRANCH}"; then
              echo "git pull ${PR_REPOSITORY} ${PR_BRANCH} done"
            else
              exit 1
            fi
            if [ "$PR_REVISION" ]; then
              git checkout -q "$PR_REVISION"
            fi
            # create a specific branch to hold the PR state
            git checkout -q -b cd-tekton-pipeline-temp-branch-for-pr
            # Step 2
            git checkout -q "${BRANCH}"
            if git merge cd-tekton-pipeline-temp-branch-for-pr; then
              echo -n "git merge of $PR_REPOSITORY (pr-branch ${PR_BRANCH} - pr_commit ${PR_REVISION}) to $REPOSITORY"
              echo " (branch $BRANCH - commit $REVISION) done in directory $DIRECTORY_NAME"
            else
              exit 1
            fi
          fi
        else
          echo "git clone of $GIT_REPOSITORY (branch $BRANCH - commit $GIT_COMMIT) done in directory $DIRECTORY_NAME"
        fi
        cd $current_dir
        if [ "$PROPERTIES_FILE" ]; then
          # Ensure directory is there
          mkdir -p $ARTIFACTS_PATH/$(dirname "$PROPERTIES_FILE")
          echo "GIT_URL=$REPOSITORY" >> $ARTIFACTS_PATH/$PROPERTIES_FILE
          echo "GIT_BRANCH=$BRANCH" >> $ARTIFACTS_PATH/$PROPERTIES_FILE
          echo "GIT_COMMIT=$GIT_COMMIT" >> $ARTIFACTS_PATH/$PROPERTIES_FILE
          # Change  write access permission to allow subsequent task(s) to update if needed
          chmod go+rw $ARTIFACTS_PATH/$PROPERTIES_FILE
          echo "$PROPERTIES_FILE content:"
          cat $ARTIFACTS_PATH/$PROPERTIES_FILE
        fi
        if [ "$JSON_FILE_GIT_CREDENTIALS" ]; then
          # Ensure directory is there
          mkdir -p $ARTIFACTS_PATH/$(dirname "$JSON_FILE_GIT_CREDENTIALS")
          # Create a JSON file as output of this step to store the git credentials for future use
          echo "{" > "${ARTIFACTS_PATH}/${JSON_FILE_GIT_CREDENTIALS}"
          echo "\"GIT_REPOSITORY\":\"${REPOSITORY}\"," >> "${ARTIFACTS_PATH}/${JSON_FILE_GIT_CREDENTIALS}"
          echo "\"GIT_AUTH_USER\":\"${GIT_AUTH_USER}\"," >> "${ARTIFACTS_PATH}/${JSON_FILE_GIT_CREDENTIALS}"
          echo "\"GIT_TOKEN\":\"${GIT_TOKEN}\"" >> "${ARTIFACTS_PATH}/${JSON_FILE_GIT_CREDENTIALS}"
          echo "}" >> "${ARTIFACTS_PATH}/${JSON_FILE_GIT_CREDENTIALS}"
        fi

        # Record task results
        echo -n "${REPOSITORY}" > $(results.git-repository.path)
        echo -n "${BRANCH}" > $(results.git-branch.path)
        echo -n "${GIT_COMMIT}" > $(results.git-commit.path)
        echo -n "${GIT_AUTH_USER}" > $(results.git-user.path)
      volumeMounts:
        - mountPath: /steps
          name: steps-volume
  volumes:
    - name: steps-volume
      emptyDir: {}
    - name: cd-config-volume
      configMap:
        name: toolchain
        items:
          - key: toolchain.json
            path: toolchain.json
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: toolchain-extract-value
spec:
  params:
    - name: config-map-name
      description: name of the config map
      default: toolchain
    - name: config-map-key
      description: key of the config map
      default: toolchain.json
    - name: expression
      description: A valid jq expression which is used to search
    - name: pipeline-debug
      description: Pipeline debug mode
      default: "0"
    - name: raw
      description: determines if extracted value should be a raw string
      default: "1"
  results:
    - name: extracted-value
      description: The extracted value
  stepTemplate:
    env:
      - name: PIPELINE_DEBUG
        value: $(params.pipeline-debug)
  steps:
    - name: extract-value-jq
      image: ibmcom/pipeline-base-image:2.6
      env:
        - name: RAW
          value: $(params.raw)
      command: ["/bin/bash", "-c"]
      args:
        - |
          #!/bin/bash
          set -e -o pipefail;

          if [ $PIPELINE_DEBUG == 1 ]; then
            pwd
            env
            trap env EXIT
            set -x
          fi

          jq $([ "$RAW" == 1 ] && echo -r) '$(params.expression)' /cd-config/$(params.config-map-key) | tr -d '\n' | tee $(results.extracted-value.path)

          file_size=$(du -b $(results.extracted-value.path) | awk '{print $1}')
          file_lines=$(wc -l $(results.extracted-value.path) | awk '{print $1}')

          if [ $file_lines -gt 80 ] || [ $file_size -gt 2048 ]; then
            echo "Error: The extracted value is over 2048 Bytes or 80 lines - It can't be stored in result."
            exit 1
          fi

      volumeMounts:
        - mountPath: /cd-config
          name: cd-config-volume
  volumes:
    - name: cd-config-volume
      configMap:
        name: $(params.config-map-name)
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: cra-terraform-scan
spec:
  params:
    - name: ibmcloud-api
      description: the ibmcloud api
      default: https://cloud.ibm.com
    - name: repository
      description: the git repo
    - name: revision
      description: the revision
      default: master
    - name: tf-dir
      description: the directory where the terraform main entry file is found
      default: ""
    - name: API_KEY
      description: field in the secret that contains the api key used to login to ibmcloud
      default: apikey
    - name: continuous-delivery-context-secret
      description: Reference name for the secret resource
      default: "secure-properties"
    - name: directory-name
      description: directory name where the repository is cloned
    - name: pipeline-debug
      description: toggles debug mode for the pipeline
      default: "0"
    - name: policy-config-json
      description: Configure policies to control thresholds
      default: ""
    - name: pr-url
      description: pull request html url
      default: ""
    - name: project-id
      description: for gitlab repository, specify project-id
      default: ""
    - name: scm-type
      description: source code type used (github, github-ent, gitlab)
      default: "github-ent"
    - name: resource-group
      description: target resource group (name or id) for the ibmcloud login operation
      default: ""
    - name: git-access-token
      description: |
        (optional) token to access the git repository. If this token is provided, there will not be an attempt
        to use the git token obtained from the authorization flow when adding the git integration in the toolchain
      default: ""
    - name: tf-var-file
      description: (optional) terraform var-file
      default: ""

  results:
    - name: status
      description: status of deployment analyzer task, possible value are- success|failed
    - name: evidence-store
      description: filepath to store deployment analyzer task evidence

  stepTemplate:
    env:
      - name: PIPELINE_RUN_ID
        valueFrom:
          fieldRef:
            fieldPath: metadata.annotations['devops.cloud.ibm.com/tekton-pipeline']
      - name: PIPELINE_DEBUG
        value: $(params.pipeline-debug)
      - name: VAR_FILE
        value: $(params.tf-var-file)
  steps:
    - name: terraform-compliance
      image: icr.io/continuous-delivery/cra-terraform:release.1480
      envFrom:
        - configMapRef:
            name: environment-properties
        - secretRef:
            name: secure-properties
      env:
        - name: REPOSITORY
          value: $(params.repository)
        - name: API_KEY
          valueFrom:
            secretKeyRef:
              name: $(params.continuous-delivery-context-secret)
              key: $(params.API_KEY)
              optional: true
      imagePullPolicy: Always
      command: ["/bin/bash", "-c"]
      args:
        - |
          if [[ "$PIPELINE_DEBUG" == "1" ]]; then
            pwd
            ls /artifacts/
            env
            trap env EXIT
            set -x +e           
          fi
          REPO_DIR_PATH="/artifacts/$(params.directory-name)"
          TOOLCHAIN_CONFIG=$(cat /config/toolchain.json)
          TOOLCHAIN_REGION=$(echo ${TOOLCHAIN_CONFIG} | jq -r '.region_id' | awk -F: '{print $3}')
          TOOLCHAIN_ID=$(echo ${TOOLCHAIN_CONFIG} | jq -r '.toolchain_guid')
          REGION_ID=$(echo ${TOOLCHAIN_CONFIG} | jq -r '.region_id')
          API_ENDPOINT="https://cloud.ibm.com"
          OTC_BROKER_BASE_URL="https://otcbroker.devopsinsights.cloud.ibm.com"
          if echo "${REGION_ID}" | grep -q "ys1"; then
            OTC_BROKER_BASE_URL="https://otcbroker.devopsinsights.dev.cloud.ibm.com"
            API_ENDPOINT="https://test.cloud.ibm.com"
            echo "targeting otc broker @ ${OTC_BROKER_BASE_URL}"
            echo "targeting ibm cloud @ ${API_ENDPOINT}"
          fi
          echo "Fetching users's token"
          ibmcloud config --check-version false
          ibmcloud login --apikey "f9C3JLP0v2lcZeFVcQycnVF0wgLRKjF37GR9lLlfTlRP" -a "https://cloud.ibm.com" -r "us-south"
          export IBM_CLOUD_BEARER=$(ibmcloud iam oauth-tokens --output JSON | jq -r '.iam_token' | awk '{ print $2 }')
          echo "Fetching service urls for user's data"
          HTTP_RESPONSE=$(curl --silent --write-out "HTTPSTATUS:%{http_code}" \
            -X GET "${OTC_BROKER_BASE_URL}/globalauth/toolchainids/${TOOLCHAIN_ID}" \
            --header "Authorization: Bearer ${IBM_CLOUD_BEARER}")
          HTTP_STATUS=$(echo $HTTP_RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
          if [[ "$HTTP_STATUS" -eq 401 || "$HTTP_STATUS" -eq 403 ]]; then
            echo ""
            echo "Error authenticating user for toolchain_id: ${TOOLCHAIN_ID}"
            echo "Please verify the Devops Insights card has been added to your toolchain and the api-key has access."
            exit 1
          fi
          if [[ "$HTTP_STATUS" -ne 200 ]]; then
            echo ""
            echo "Error! Please try again."
            exit 1
          fi
          HTTP_BODY=$(echo $HTTP_RESPONSE | sed -e 's/HTTPSTATUS\:.*//g')
          gitsecureUrl=$(echo ${HTTP_BODY} | jq -r '.service_urls.gitsecure')
          if [[ -z "$gitsecureUrl" || "$gitsecureUrl" = "null" ]]; then
            echo ""
            echo "Error IBM Code Risk Analyzer is not supported in ${REGION_ID}"
            exit 1
          fi
          echo "Running terraform compliance task"                    
          if [[ $PIPELINE_DEBUG == 1 ]];
            then
              ls $REPO_DIR_PATH
          fi
          result="failed"
          LOG_LEVEL="info"
          if [[ "$(params.policy-config-json)" == "" ]]; 
          then
            node /usr/src/index.js --git_token "NA" --repository $(params.repository) --gitClonedDir $REPO_DIR_PATH --INPUT_TF_DIR $(params.tf-dir) --revision $(params.revision) --commitid "NA" --pipelinerunid $PIPELINE_RUN_ID --prnumber "NA" --LOG_LEVEL $LOG_LEVEL --silent 1
          else
            node /usr/src/index.js --policyConfig $(params.policy-config-json) --git_token "NA" --repository $(params.repository) --gitClonedDir $REPO_DIR_PATH --INPUT_TF_DIR $(params.tf-dir) --revision $(params.revision) --commitid "NA" --pipelinerunid $PIPELINE_RUN_ID --prnumber "NA" --LOG_LEVEL $LOG_LEVEL --silent 1
          fi
          if [ $? == 0 ]; then export result="success"; fi          
          if [[ $PIPELINE_DEBUG == 1 ]];
            then
              cat /usr/policies/ibm/terraform-config.rego
              echo $result
              cat result.json
          fi
          echo -n $result > "$(results.status.path)"                    
          echo -n "deploymant-analyzer.json" > $(results.evidence-store.path)
          cp ./da-terraform-check-comment.md /steps/da-terraform-check-comment.md
          echo "COMMENT_FP=/steps/da-terraform-check-comment.md" >> /steps/next-step-env.properties
      volumeMounts:
        - mountPath: /config
          name: cd-config-volume
        - mountPath: /steps
          name: steps-volume

    - name: fetch-git-information
      image: ibmcom/pipeline-base-image:2.6
      env:
        - name: REPOSITORY
          value: $(params.repository)
        - name: API_ENDPOINT
          value: $(params.ibmcloud-api)
        - name: API_KEY
          valueFrom:
            secretKeyRef:
              name: $(params.continuous-delivery-context-secret)
              key: $(params.API_KEY)
              optional: true
      command: ["/bin/bash", "-c"]
      args:
        - |
          set -e -o pipefail
          if [ "$PIPELINE_DEBUG" == "1" ]; then
              pwd
              env
              trap env EXIT
              set -x
          fi
          TOOLCHAIN_ID=$(jq -r '.toolchain_guid' /cd-config/toolchain.json)
          TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json | awk -F: '{print $3}')
          REGION_ID=$(jq -r '.region_id' /cd-config/toolchain.json)
          ##########################################################################
          # Setting HOME explicitly to have ibmcloud plugins available
          # doing the export rather than env definition is a workaround
          # until https://github.com/tektoncd/pipeline/issues/1836 is fixed
          export HOME="/root"
          ##########################################################################
          if [[ "$REPOSITORY" != *.git ]]; then
            echo "Adding .git suffix to Repository URL"
            REPOSITORY="${REPOSITORY}.git"
          fi
          GIT_SERVICE_INSTANCE_ID=$(jq -r --arg git_repo "$REPOSITORY" '.services[] | select (.parameters.repo_url==$git_repo) | .instance_id' /cd-config/toolchain.json)
          if [ -z "$GIT_SERVICE_INSTANCE_ID" ]; then
            echo "No Git integration (repository url: $REPOSITORY) found in the toolchain"
            exit 1
          fi
          GIT_SERVICE_TYPE=$(jq -r --arg git_repo "$REPOSITORY" '.services[] | select (.parameters.repo_url==$git_repo) | .service_id' /cd-config/toolchain.json)
          if [ "$GIT_SERVICE_TYPE" == "github" ]; then
            GIT_AUTH_USER="x-oauth-basic"
          elif [ "$GIT_SERVICE_TYPE" == "githubpublic" ]; then
            GIT_AUTH_USER="x-oauth-basic"
          elif [ "$GIT_SERVICE_TYPE" == "hostedgit" ]; then
            GIT_AUTH_USER="oauth2"
          elif [ "$GIT_SERVICE_TYPE" == "gitlab" ]; then
            GIT_AUTH_USER="oauth2"
          elif [ "$GIT_SERVICE_TYPE" == "bitbucketgit" ]; then
            GIT_AUTH_USER="x-token-auth"
          else
            GIT_AUTH_USER="x-token-auth"
          fi;
          GIT_TOKEN="$(params.git-access-token)"
          if [ -z "$GIT_TOKEN" ]; then
            if [[ "$REGION_ID" == *"ys1"* ]]; then
              API_ENDPOINT="https://test.cloud.ibm.com"
              echo "targeting ibm cloud @ ${API_ENDPOINT}"
            fi
            echo "Fetching token for $REPOSITORY"
            ibmcloud config --check-version false
            ibmcloud login --apikey "f9C3JLP0v2lcZeFVcQycnVF0wgLRKjF37GR9lLlfTlRP" -a "https://cloud.ibm.com" -r "us-south"
            if [ "$(params.resource-group)" ]; then
              ibmcloud target -g $(params.resource-group)
            fi
            TOKEN=$(ibmcloud iam oauth-tokens --output JSON | jq -r '.iam_token')
            GIT_TOKEN_URL=$(jq -r --arg git_repo "$REPOSITORY" '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.token_url' /cd-config/toolchain.json)
            # GIT_TOKEN_URL is like https://otc-github-consolidated-broker.us-south.devops.cloud.ibm.com/github/token?git_id=github
            # as there is already an url param git_id, just put the additional ones using &
            echo "Doing cURL to ${GIT_TOKEN_URL}&toolchain_id=${TOOLCHAIN_ID}&service_instance_id=${GIT_SERVICE_INSTANCE_ID}&repo_url=${REPOSITORY}"
            curl -s -o /steps/github_token_result.json -X GET -H "Accept: application/json" -H "Authorization: $TOKEN" "${GIT_TOKEN_URL}&toolchain_id=${TOOLCHAIN_ID}&service_instance_id=${GIT_SERVICE_INSTANCE_ID}&repo_url=${REPOSITORY}"
            if jq -e '.access_token' /steps/github_token_result.json > /dev/null 2>&1; then
              GIT_TOKEN=$(jq -r '.access_token' /steps/github_token_result.json)
              echo "Access token found for the Git integration (repository url: $REPOSITORY)"
            else
              echo "No access token found for the Git integration (repository url: $REPOSITORY)"
              cat /steps/github_token_result.json
              exit 1
            fi
          else
            echo "Using git Access Token provided"
          fi
          GIT_API_ROOT_URL=$(jq -r --arg git_repo "$REPOSITORY" '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.api_root_url' /cd-config/toolchain.json)
          GIT_OWNER_ID=$(jq -r --arg git_repo "$REPOSITORY" '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.owner_id' /cd-config/toolchain.json)
          GIT_REPO_NAME=$(jq -r --arg git_repo "$REPOSITORY" '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.repo_name' /cd-config/toolchain.json)
          GIT_ID=$(jq -r --arg git_repo "$REPOSITORY" '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.git_id' /cd-config/toolchain.json)
          TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json | awk -F: '{print $3}')
          echo "GIT_REPOSITORY=$REPOSITORY" >> /steps/next-step-env.properties
          echo "GIT_AUTH_USER=$GIT_AUTH_USER" >> /steps/next-step-env.properties
          echo "GIT_TOKEN=$GIT_TOKEN" >> /steps/next-step-env.properties
          echo "GIT_SERVICE_TYPE=$GIT_SERVICE_TYPE" >> /steps/next-step-env.properties
          echo "GIT_ID=$GIT_ID" >> /steps/next-step-env.properties
          echo "GIT_API_ROOT_URL=$GIT_API_ROOT_URL" >> /steps/next-step-env.properties
          echo "GIT_OWNER_ID=$GIT_OWNER_ID" >> /steps/next-step-env.properties
          echo "GIT_REPO_NAME=$GIT_REPO_NAME" >> /steps/next-step-env.properties
          echo "TOOLCHAIN_REGION=$TOOLCHAIN_REGION" >> /steps/next-step-env.properties
          if [ "$PIPELINE_DEBUG" == "1" ]; then
            cat /steps/next-step-env.properties
          fi
      volumeMounts:
        - mountPath: /cd-config
          name: cd-config-volume
        - mountPath: /steps
          name: steps-volume

    - name: comment-editor
      image: icr.io/continuous-delivery/cra-comm-editor:main.1260
      imagePullPolicy: Always
      workingDir: "/artifacts"
      command: ["/bin/sh", "-c"]
      args:
        - |
          #!/bin/sh
          source /steps/next-step-env.properties
          /usr/local/bin/comm-editor \
            -repo-url "$(params.repository)" \
            -pr-url "$(params.pr-url)" \
            -token "$GIT_TOKEN" \
            -comment-fp "$COMMENT_FP" \
            -project-id "$(params.project-id)" \
            -scm-type "$(params.scm-type)"
      volumeMounts:
        - mountPath: /steps
          name: steps-volume

  workspaces:
    - name: artifacts
      mountPath: /artifacts
    - name: secrets
      mountPath: /secrets

  volumes:
    - name: steps-volume
      emptyDir: {}
    - name: secrets
      secret:
        secretName: $(params.continuous-delivery-context-secret)
    - name: cd-config-volume
      configMap:
        name: toolchain
        items:
          - key: toolchain.json
            path: toolchain.json
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: update-workspace-task
spec:
  params:
    - name: API_KEY
      description: the ibmcloud api key
    - name: WORKSPACE_ID
      description: the workspace id
  workspaces:
    - name: task-ws
      mountPath: /artifacts
  steps:
    - name: update-workspace
      image: ibmcom/pipeline-base-image
      env:
        - name: API_KEY
          value: $(params.API_KEY)
        - name: WORKSPACE_ID
          value: $(params.WORKSPACE_ID)
      command: ["/bin/bash", "-c"]
      args:
        - |
          #!/bin/bash
          echo "Workspace $WORKSPACE_ID"
          # force login (required by schematics cli)
          ibmcloud login --apikey $API_KEY -a "https://cloud.ibm.com" --no-region
          # get schematics workspace as json
          WORKSPACE=$(ibmcloud terraform workspace get -i $WORKSPACE_ID --json)
          echo "Updating Schematics workspace from environment variables..."
          # iterate over ALL schematics worskpace variables to see if there is a matching env var
          for KEY in $(echo $WORKSPACE | jq ".template_data[0].values_metadata[].name" -r); do
              
              # if the value exists as an env var, update the workspace
              if [ -n "${!KEY}" ]; then
                  echo "$KEY found with value '${!KEY}'"; 
                  SEARCH=$(echo $WORKSPACE | jq ".template_data[0].variablestore[].name")
                  
                  if [[ "$SEARCH" =~ .*"$KEY".* ]]; then
                      #echo "It's there, update it."
                      WORKSPACE=$(echo $WORKSPACE | jq -r \
                          --arg updateKey "$KEY" \
                          --arg updateVal "${!KEY}" \
                          '.template_data[0].variablestore = [.template_data[0].variablestore[] | if (.name == $updateKey) then (.value = $updateVal) else . end]' )
                  else 
                      #echo "It's NOT there, add it."
                      WORKSPACE=$(echo $WORKSPACE | jq -r ".template_data[0].variablestore[.template_data[0].variablestore| length] |= . + { \"name\": \"$KEY\", \"value\": \"${!KEY}\", \"type\": \"string\" }")
                      
                  fi
              fi
          done
          echo $WORKSPACE > workspace.json
          ibmcloud terraform workspace update --id $WORKSPACE_ID --file workspace.json
          # cleanup
          rm -f workspace.json
          sleep 10
          unset WORKSPACE
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: plan-task
spec:
  params:
    - name: API_KEY
      description: the ibmcloud api key
    - name: WORKSPACE_ID
      description: the workspace id
  workspaces:
    - name: task-ws
      mountPath: /artifacts
  steps:
    - name: terraform-plan
      image: ibmcom/pipeline-base-image
      env:
        - name: API_KEY
          value: $(params.API_KEY)
        - name: WORKSPACE_ID
          value: $(params.WORKSPACE_ID)
      command: ["/bin/bash", "-c"]
      args:
        - |
          #!/bin/bash
          ibmcloud login --apikey $API_KEY -a "https://cloud.ibm.com" --no-region
          # run terraform plan
          echo "ibmcloud terraform plan --id $WORKSPACE_ID"
          ACTIVITY=$(ibmcloud terraform plan -id $WORKSPACE_ID --json)
          ACTIVITY_ID=$(echo $ACTIVITY | jq -r ".activityid")
          echo "Activity ID   $ACTIVITY_ID"
          # poll until status is no longer INPROGRESS, or if there is an error
          while :
          do
            STATUS=$(ibmcloud terraform workspace action --id $WORKSPACE_ID --act-id $ACTIVITY_ID --json)
            
            RET_VAL=$?
            if [ $RET_VAL -ne 0 ]; then
              echo $STATUS
              exit $RET_VAL
            else
              STATUS_VALUE=$(echo $STATUS | jq -r ".status")
              echo "Polling for status: $STATUS_VALUE"
              if [ "$STATUS_VALUE" = "FAILED" ]; then 
                ibmcloud terraform logs --id $WORKSPACE_ID --act-id $ACTIVITY_ID
                exit 1
              elif [ "$STATUS_VALUE" != "INPROGRESS" ] && [ "$STATUS_VALUE" != "CREATED" ]; then  
                break
              fi
            fi
            # sleep for 5 seconds, while waiting for completion
            sleep 5
          done
          ibmcloud terraform logs --id $WORKSPACE_ID --act-id $ACTIVITY_ID
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: apply-task
spec:
  params:
    - name: API_KEY
      description: the ibmcloud api key
    - name: WORKSPACE_ID
      description: the workspace id
  workspaces:
    - name: task-ws
      mountPath: /artifacts
  steps:
    - name: terraform-apply
      image: ibmcom/pipeline-base-image
      env:
        - name: API_KEY
          value: $(params.API_KEY)
        - name: WORKSPACE_ID
          value: $(params.WORKSPACE_ID)
      command: ["/bin/bash", "-c"]
      args:
        - |
          #!/bin/bash
          ibmcloud login --apikey $API_KEY -a "https://cloud.ibm.com" --no-region
          # run terraform apply
          echo "ibmcloud terraform apply --id $WORKSPACE_ID --force"
          ACTIVITY=$(ibmcloud terraform apply -id $WORKSPACE_ID --json --force)
          ACTIVITY_ID=$(echo $ACTIVITY | jq -r ".activityid")
          echo "Activity ID   $ACTIVITY_ID"
          # poll until status is no longer INPROGRESS, or if there is an error
          while :
          do
            STATUS=$(ibmcloud terraform workspace action --id $WORKSPACE_ID --act-id $ACTIVITY_ID --json)
            
            RET_VAL=$?
            if [ $RET_VAL -ne 0 ]; then
              echo $STATUS
              exit $RET_VAL
            else
              STATUS_VALUE=$(echo $STATUS | jq -r ".status")
              echo "Polling for status: $STATUS_VALUE"
              if [ "$STATUS_VALUE" = "FAILED" ]; then
                ibmcloud terraform logs --id $WORKSPACE_ID --act-id $ACTIVITY_ID
                exit 1
              elif [ "$STATUS_VALUE" != "INPROGRESS" ]; then  
                break
              fi
            fi
            # sleep for 5 seconds, while waiting for completion
            sleep 5
          done
          ibmcloud terraform logs --id $WORKSPACE_ID --act-id $ACTIVITY_ID
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: test-task
spec:
  workspaces:
    - name: task-ws
      mountPath: /artifacts
  steps:
    - name: check-health
      image: ibmcom/pipeline-base-image
      command: ["/bin/bash", "-c"]
      args:
        - echo "You can add tests here to ensure that your resources are healthy!"
